# 堆排序

https://www.cnblogs.com/lylhome/p/13276081.html


### 时间复杂度分析

堆排序分为两步，即初始化堆、调整堆。

 

两个步骤都要调用一个调整结点顺序的函数NodeSort，以大根堆为例，操作为：

1：如果父亲结点num[a]和它的两个孩子结点num[2a+1], num[2a+2]满足um[a] > max{num[2a+1], num[2a+2]}，那么返回；

2：如果不满足堆的性质，那么将父亲结点num[a]和较大孩子结点max{num[2a+1], num[2a+2]}交换，

3：将原来较大的孩子结点作为父亲结点，重复上述操作，直到孩子结点是叶子结点为止

 

初始化堆的时间复杂度分析

初始化堆的时候，对于每个非叶子结点，都要调用上述函数，将它与它的孩子结点进行比较和交换，顺序是从后向前。

以操作2作为基本操作，对每一层都完全铺满的堆进行分析，

设元素个数为n，则堆的高度k=log（n+1）≈log n，非叶子结点的个数为2^（k-1）-1

假设每个非叶子结点都需要进行调整，则第i层的非叶子结点需要的操作次数为k-i，

第i层共有2^（i-1）个结点，则第i层的所有结点所做的操作为k*2^（i-1）- i*2^（i-1），

共k-1层非叶子结点，总的操作次数为 

$$ \sum_{i=1}^{k-1} (k*2^{i-1} - i * 2^{i-1})$$ 

化简可得，上式=$2^k-k+1$，将k=log（n+1）≈ log n代入，得n - log n +1，

那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；

        S = 2^(k-2) * 1 + 2^(k-3)*2.....+2*(k-2)+2^(0)*(k-1)  ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；

        这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：

        S = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ..... + 2 - (k-1)

        除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；

        S = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) <=  n < (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) < k <= logn ）;

        综上所述得到：S = n - longn -1，所以时间复杂度为：O(n)
所以，初始化堆的复杂度为O(n)

1. 堆的构建时间是：O(n)

2. 每次调整的指令操作次数是：根节点和排在最后的序号为m的叶子结点交换，并进行调整，那么调整的操作次数 = 原来m结点所在的层数 = 堆的高度（因为m结点在堆的最后）= $log_{2} m$

https://blog.csdn.net/lanchunhui/article/details/51473692
https://stackoverflow.com/questions/2095395/is-logn-%CE%98n-logn
总时间即：$p=\sum_{i=1}^{n-1} \log_2i = log_2(n-1)! \approx n*log_2n$
